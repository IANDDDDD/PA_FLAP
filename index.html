<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Play Area </title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #050509;
      overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto;
    }
    body {
      display: flex;
    }
    #game {
      flex: 1;
      width: 100%;
      height: 100%;
      display: block;
    }
    .badge {
      position: fixed;
      left: 16px;
      bottom: 16px;
      font-size: 12px;
      opacity: .6;
      color: #fff;
      pointer-events: none;
    }
  </style>
</head>
<body>

<canvas id="game"></canvas>
<div class="badge">Play Area — Playing &gt; Posting</div>

<script>
// FRAME-FRIENDLY FLAPPY — neon pink pipes + reference-style smiley face
(function () {
  const c = document.getElementById("game");
  const x = c.getContext("2d");

  // Resize canvas to fill its parent (works nicely inside Framer iframe)
  function resize() {
    const rect = c.getBoundingClientRect();
    c.width = rect.width || window.innerWidth;
    c.height = rect.height || window.innerHeight;
  }
  window.addEventListener("resize", resize);
  resize();

  const W = () => c.width;
  const H = () => c.height;

  let started = false, over = false, score = 0, best = 0;
  let last = performance.now(), spawn = 0;

  const bird = { x: 0, y: 0, r: 18, vy: 0 };
  const pipes = [];

  // Tuned constants
  const G      = 950;    // gravity
  const FLAP   = -320;   // flap impulse
  const SPEED  = 220;    // pipe speed (px/sec)
  const PIPE_W = 90;     // pipe width
  const GAP    = 220;    // fixed gap so iframe height doesn't kill it

  function reset() {
    started = false;
    over = false;
    score = 0;
    bird.x = W() * 0.28;
    bird.y = H() * 0.5;
    bird.vy = 0;
    pipes.length = 0;
    spawn = 0;
    last = performance.now();
  }

  function flap() {
    if (over) {
      reset();
      return;
    }
    started = true;
    bird.vy = FLAP;
  }

  c.addEventListener("pointerdown", flap);
  window.addEventListener("keydown", (e) => {
    if (e.code === "Space" || e.code === "ArrowUp") {
      e.preventDefault();
      flap();
    }
  });

  function addPipe() {
    const h = H();
    const minTop = 40;
    const maxTop = Math.max(minTop, h - GAP - 80);
    const topH = minTop + Math.random() * (maxTop - minTop);
    pipes.push({ x: W() + PIPE_W, topH, passed: false });
  }

  function update(dt) {
    if (!started || over) return;

    bird.vy += G * dt;
    bird.y += bird.vy * dt;

    spawn += dt;
    if (spawn > 1.35) {
      spawn = 0;
      addPipe();
    }

    const move = SPEED * dt;
    for (const p of pipes) {
      p.x -= move;
      if (!p.passed && p.x + PIPE_W < bird.x - bird.r) {
        p.passed = true;
        score++;
        best = Math.max(best, score);
      }
    }

    while (pipes.length && pipes[0].x < -PIPE_W - 10) {
      pipes.shift();
    }

    // top / bottom collision
    if (bird.y - bird.r < 0 || bird.y + bird.r > H()) {
      over = true;
    }

    // pipe collisions
    for (const p of pipes) {
      if (bird.x + bird.r > p.x && bird.x - bird.r < p.x + PIPE_W) {
        if (bird.y - bird.r < p.topH || bird.y + bird.r > p.topH + GAP) {
          over = true;
        }
      }
    }
  }

  // draw the reference-style smiley face
  function drawSmiley() {
    const r = bird.r;

    x.save();
    x.translate(bird.x, bird.y);

    // FACE FILL (light green)
    x.beginPath();
    x.fillStyle = "#E8FFC2";
    x.arc(0, 0, r, 0, Math.PI * 2);
    x.fill();

    // OUTLINE (thick pink ring)
    x.strokeStyle = "#FF00AD";
    x.lineWidth = r * 0.35;
    x.stroke();

    // EYES (pink dots)
    x.fillStyle = "#FF00AD";
    const eyeR = r * 0.18;
    const eyeOffsetX = r * 0.32;
    const eyeOffsetY = r * 0.28;

    x.beginPath();
    x.arc(-eyeOffsetX, -eyeOffsetY, eyeR, 0, Math.PI * 2);
    x.fill();

    x.beginPath();
    x.arc(eyeOffsetX, -eyeOffsetY, eyeR, 0, Math.PI * 2);
    x.fill();

    // MOUTH (wide pink half-circle)
    const mouthR = r * 0.55;
    const mouthY = r * 0.15;

    x.beginPath();
    x.fillStyle = "#FF00AD";
    x.arc(0, mouthY, mouthR, 0, Math.PI, false);
    x.fill();

    x.restore();
  }

  function draw() {
    // background gradient
    const grad = x.createLinearGradient(0, 0, 0, H());
    grad.addColorStop(0, "#050515");
    grad.addColorStop(1, "#05050a");
    x.fillStyle = grad;
    x.fillRect(0, 0, W(), H());

    // pipes: neon pink
    x.fillStyle = "#FF00AD";
    for (const p of pipes) {
      x.fillRect(p.x, 0, PIPE_W, p.topH);
      x.fillRect(p.x, p.topH + GAP, PIPE_W, H());
    }

    // smiley bird
    drawSmiley();

    // score
    x.fillStyle = "#ffffff";
    x.font = "bold 32px system-ui";
    x.textAlign = "left";
    x.fillText(score, 20, 40);

    // messages
    x.textAlign = "center";
    if (!started && !over) {
      x.font = "28px system-ui";
      x.fillText("THE PLAY AREA", W() / 2, H() * 0.45);
      x.font = "18px system-ui";
      x.fillText("Tap / Space to start", W() / 2, H() * 0.52);
    }
    if (over) {
      x.font = "32px system-ui";
      x.fillText("Game Over", W() / 2, H() * 0.45);
      x.font = "18px system-ui";
      x.fillText("Tap / Space to restart", W() / 2, H() * 0.52);
    }
  }

  function loop(t) {
    const dt = Math.min(0.03, (t - last) / 1000);
    last = t;
    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  reset();
  requestAnimationFrame(loop);
})();
</script>

</body>
</html>

